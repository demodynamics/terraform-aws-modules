# RSA Key Resource (uses rsa_bits)
resource "tls_private_key" "rsa_ssh" {
  count     = var.tls_private_key_algorithm == "RSA" ? 1 : 0
  algorithm = "RSA"
  rsa_bits  = var.tls_private_key_bits

  # Note: The count parameter ensures this entire block is skipped 
  # when var.tls_private_key_algorithm is not "RSA".
}

# ED25519 Key Resource (no bits argument)
resource "tls_private_key" "ed25519_ssh" {
  count     = var.tls_private_key_algorithm == "ED25519" ? 1 : 0
  algorithm = "ED25519"
}

#ECDSA Key Resource (uses ecdsa_curve)
resource "tls_private_key" "ecdsa_ssh" {
  count     = var.tls_private_key_algorithm == "ECDSA" ? 1 : 0
  algorithm = "ECDSA"
  # You would need to add a variable for the specific curve, e.g., P256
  ecdsa_curve = var.ecdsa_curve
}


resource "aws_key_pair" "ssh" {
  key_name = try(var.aws_key_pair_name, "ec2-ssh-key")

  public_key = one(concat(
    # References the public key from the RSA resource if it was created (count=1)
    tls_private_key.rsa_ssh[*].public_key_openssh,

    # References the public key from the ED25519 resource if it was created (count=1)
    tls_private_key.ed25519_ssh[*].public_key_openssh,

    # References the public key from the ECDSA resource if it was created (count=1)
    tls_private_key.ecdsa_ssh[*].public_key_openssh,
  ))

  tags = merge(var.tags, {
    Name = "${var.aws_key_pair_name}${var.key_name_suffix}"
  })
}



resource "local_file" "eks_ssh_private_key" {
  count = var.write_local_file ? 1 : 0

  # --- CORRECTED CONTENT REFERENCE ---
  content = one(concat(
    # References the private key from the RSA resource if it was created
    tls_private_key.rsa_ssh[*].private_key_pem,

    # References the private key from the ED25519 resource if it was created
    tls_private_key.ed25519_ssh[*].private_key_openssh,

    # References the private key from the ECDSA resource if it was created
    tls_private_key.ecdsa_ssh[*].private_key_openssh,
  ))
  # -----------------------------------

  filename             = try(var.ssh_private_key_filename, "./ec2-ssh-key.pem")
  file_permission      = try(var.ssh_private_key_file_permission, "0400")
  directory_permission = try(var.ssh_private_key_directory_permission, "0700")
}




# /*
# Generating SSH key pair for accessing EC2 insances (EKS Nodes) directly with Terraform:

# - The tls_private_key resource creates a new private/public key pair.
# - The aws_key_pair resource uploads the public key to AWS as an EC2 key pair.
# - The output eks_ssh_private_key_pem provides the private key (sensitive)—save this securely and never 
# commit it to version control.

# Use aws_key_pair.eks_ssh.key_name as your node_ssh_key variable, and you’re ready for secure SSH access! 
# If you want the private key written to a file automatically, let me know.*/

# resource "tls_private_key" "ssh" {
#   algorithm = try(var.tls_private_key_algorithm, "RSA")
#   rsa_bits  = try(var.tls_private_key_bits, 4096)

#   /*The resource tls_private_key "ssh" creates a new RSA public/private key pair in memory when you run 
#   terraform apply.

# - The private key is available as tls_private_key.ssh.private_key_pem (in PEM format).
# - The public key is available as tls_private_key.ssh.public_key_openssh (in OpenSSH format).

# These values are stored in Terraform state and can be output or written to files 
# (as you do with the local_file resource). The keys are not saved to disk automatically unless you explicitly 
# write them to a file using Terraform resources like local_file.


# The resource tls_private_key "ssh" does NOT create anything in AWS.

# - It only generates a public/private key pair locally (in Terraform memory/state).
# - The actual AWS resource is created by aws_key_pair "ssh", which uploads the public key to AWS as an EC2 key 
# pair.
# - The tls_private_key resource is just for key generation; it does not interact with AWS directly.

# So, only aws_key_pair and aws_eks_node_group create resources in AWS. The tls_private_key resource is for 
# local cryptographic key management.

# */
# }

# resource "aws_key_pair" "ssh" {
#   key_name   = try(var.aws_key_pair_name, "ec2-ssh-key")
#   public_key = tls_private_key.ssh.public_key_openssh

#   tags = merge(var.tags, {
#     Name = "${var.aws_key_pair_name}${var.key_name_suffix}"
#   })
#   /*
#   The resource aws_key_pair "ssh" uploads the public key (generated by tls_private_key.ssh) to AWS, which can be attached to EC2 instance inorder to grant ssh inbound connection to that instance by that public key. 
#   key pair.

# - The public key is stored in AWS under the name ec2-ssh-key.
# - You can find it in the AWS Console under EC2 → Network & Security → Key Pairs.
# - AWS does not store the private key—only the public key is saved in AWS.

# This allows you to reference ec2-ssh-key when launching EC2 instances (including EKS nodes), enabling SSH 
# access with the corresponding private key.
#   */
# }

# resource "local_file" "eks_ssh_private_key" {
#   count                = var.write_local_file ? 1 : 0
#   content              = tls_private_key.ssh.private_key_pem
#   filename             = try(var.ssh_private_key_filename, "./ec2-ssh-key.pem")
#   file_permission      = try(var.ssh_private_key_file_permission, "0400")
#   directory_permission = try(var.ssh_private_key_directory_permission, "0700")

#   /*
# - The SSH private key will be saved as ec2-ssh-key.pem in your working directory with secure permissions.
# - You can use this file directly to SSH into your EKS nodes (if remote_access block in node group module is 
# enabled and security group allows it).

# Remember: Keep eks-ssh-key.pem safe and never commit it to version control. If you need further automation or
# want to customize the path, let me know!*/
# }


